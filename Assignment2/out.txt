In file included from /usr/local/include/grppi/dyn/dynamic_execution.h:19,
                 from /usr/local/include/grppi/grppi.h:20,
                 from grppi.cpp:6:
/usr/local/include/grppi/dyn/../seq/sequential_execution.h: In instantiation of 'void grppi::sequential_execution::do_pipeline(Item&&, Transformer&&, OtherTransformers&& ...) const [with Item = std::vector<int>*&; Transformer = main(int, char**)::<lambda(std::vector<int>*)>; OtherTransformers = {main(int, char**)::<lambda(std::vector<int, std::allocator<int> >*)>}; typename std::enable_if<is_no_pattern<Consumer>, int>::type <anonymous> = 0]':
/usr/local/include/grppi/dyn/../seq/sequential_execution.h:571:5:   required from 'void grppi::sequential_execution::pipeline(Generator&&, Transformers&& ...) const [with Generator = main(int, char**)::<lambda()>; Transformers = {main(int, char**)::<lambda(std::vector<int, std::allocator<int> >*)>, main(int, char**)::<lambda(std::vector<int, std::allocator<int> >*)>}]'
/usr/local/include/grppi/dyn/dynamic_execution.h:405:3:   required from 'void grppi::dynamic_execution::pipeline(Generator&&, Transformers&& ...) const [with Generator = main(int, char**)::<lambda()>; Transformers = {main(int, char**)::<lambda(std::vector<int, std::allocator<int> >*)>, main(int, char**)::<lambda(std::vector<int, std::allocator<int> >*)>}]'
/usr/local/include/grppi/pipeline.h:53:3:   required from 'void grppi::pipeline(const Execution&, Generator&&, Transformers&& ...) [with Execution = grppi::dynamic_execution; Generator = main(int, char**)::<lambda()>; Transformers = {main(int, char**)::<lambda(std::vector<int, std::allocator<int> >*)>, main(int, char**)::<lambda(std::vector<int, std::allocator<int> >*)>}; typename std::enable_if<is_supported<typename std::decay<_Tp>::type>(), int>::type <anonymous> = 0]'
grppi.cpp:62:9:   required from here
/usr/local/include/grppi/dyn/../seq/sequential_execution.h:591:17: error: static assertion failed: Intermediate pipeline stage cannot be a consumer
   static_assert(!is_consumer<Transformer,Item>,
                 ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
/usr/local/include/grppi/dyn/../seq/sequential_execution.h:594:3: error: invalid use of void expression
   do_pipeline(transform_op(std::forward<Item>(item)),
   ^~~~~~~~~~~
In file included from grppi.cpp:4:
/usr/local/include/c++/8.3.0/experimental/optional: In instantiation of 'class std::experimental::fundamentals_v1::_Optional_base<void, true>':
/usr/local/include/c++/8.3.0/experimental/optional:491:11:   required from 'class std::experimental::fundamentals_v1::optional<void>'
/usr/local/include/c++/8.3.0/bits/stl_pair.h:214:11:   required from 'struct std::pair<std::experimental::fundamentals_v1::optional<void>, long int>'
/usr/local/include/c++/8.3.0/type_traits:920:12:   required from 'struct std::is_constructible<std::pair<std::experimental::fundamentals_v1::optional<void>, long int>, std::pair<std::experimental::fundamentals_v1::optional<void>, long int>&&>'
/usr/local/include/c++/8.3.0/type_traits:131:12:   required from 'struct std::__and_<std::is_constructible<std::pair<std::experimental::fundamentals_v1::optional<void>, long int>, std::pair<std::experimental::fundamentals_v1::optional<void>, long int>&&>, std::__is_nt_constructible_impl<std::pair<std::experimental::fundamentals_v1::optional<void>, long int>, std::pair<std::experimental::fundamentals_v1::optional<void>, long int>&&> >'
/usr/local/include/c++/8.3.0/type_traits:1005:12:   required from 'struct std::is_nothrow_constructible<std::pair<std::experimental::fundamentals_v1::optional<void>, long int>, std::pair<std::experimental::fundamentals_v1::optional<void>, long int>&&>'
/usr/local/include/c++/8.3.0/type_traits:1036:12:   [ skipping 8 instantiation contexts, use -ftemplate-backtrace-limit=0 to disable ]
/usr/local/include/grppi/dyn/../seq/../common/mpmc_queue.h:438:30:   required from 'class grppi::mpmc_queue<std::pair<std::experimental::fundamentals_v1::optional<void>, long int> >'
/usr/local/include/grppi/dyn/../native/parallel_execution_native.h:1089:18:   required from 'void grppi::parallel_execution_native::do_pipeline(Queue&, Transformer&&, OtherTransformers&& ...) const [with Queue = grppi::mpmc_queue<std::pair<std::experimental::fundamentals_v1::optional<std::vector<int>*>, long int> >; Transformer = main(int, char**)::<lambda(std::vector<int>*)>; OtherTransformers = {main(int, char**)::<lambda(std::vector<int, std::allocator<int> >*)>}; typename std::enable_if<is_no_pattern<Consumer>, int>::type <anonymous> = 0]'
/usr/local/include/grppi/dyn/../native/parallel_execution_native.h:887:3:   required from 'void grppi::parallel_execution_native::pipeline(Generator&&, Transformers&& ...) const [with Generator = main(int, char**)::<lambda()>; Transformers = {main(int, char**)::<lambda(std::vector<int, std::allocator<int> >*)>, main(int, char**)::<lambda(std::vector<int, std::allocator<int> >*)>}]'
/usr/local/include/grppi/dyn/dynamic_execution.h:405:3:   required from 'void grppi::dynamic_execution::pipeline(Generator&&, Transformers&& ...) const [with Generator = main(int, char**)::<lambda()>; Transformers = {main(int, char**)::<lambda(std::vector<int, std::allocator<int> >*)>, main(int, char**)::<lambda(std::vector<int, std::allocator<int> >*)>}]'
/usr/local/include/grppi/pipeline.h:53:3:   required from 'void grppi::pipeline(const Execution&, Generator&&, Transformers&& ...) [with Execution = grppi::dynamic_execution; Generator = main(int, char**)::<lambda()>; Transformers = {main(int, char**)::<lambda(std::vector<int, std::allocator<int> >*)>, main(int, char**)::<lambda(std::vector<int, std::allocator<int> >*)>}; typename std::enable_if<is_supported<typename std::decay<_Tp>::type>(), int>::type <anonymous> = 0]'
grppi.cpp:62:9:   required from here
/usr/local/include/c++/8.3.0/experimental/optional:299:7: error: forming reference to void
       _M_get() noexcept
       ^~~~~~
/usr/local/include/c++/8.3.0/experimental/optional:303:7: error: forming reference to void
       _M_get() const noexcept
       ^~~~~~
/usr/local/include/c++/8.3.0/experimental/optional: In instantiation of 'union std::experimental::fundamentals_v1::_Optional_base<void, true>::<unnamed>':
/usr/local/include/c++/8.3.0/experimental/optional:335:7:   required from 'class std::experimental::fundamentals_v1::_Optional_base<void, true>'
/usr/local/include/c++/8.3.0/experimental/optional:491:11:   required from 'class std::experimental::fundamentals_v1::optional<void>'
/usr/local/include/c++/8.3.0/bits/stl_pair.h:214:11:   required from 'struct std::pair<std::experimental::fundamentals_v1::optional<void>, long int>'
/usr/local/include/c++/8.3.0/type_traits:920:12:   required from 'struct std::is_constructible<std::pair<std::experimental::fundamentals_v1::optional<void>, long int>, std::pair<std::experimental::fundamentals_v1::optional<void>, long int>&&>'
/usr/local/include/c++/8.3.0/type_traits:131:12:   required from 'struct std::__and_<std::is_constructible<std::pair<std::experimental::fundamentals_v1::optional<void>, long int>, std::pair<std::experimental::fundamentals_v1::optional<void>, long int>&&>, std::__is_nt_constructible_impl<std::pair<std::experimental::fundamentals_v1::optional<void>, long int>, std::pair<std::experimental::fundamentals_v1::optional<void>, long int>&&> >'
/usr/local/include/c++/8.3.0/type_traits:1005:12:   [ skipping 9 instantiation contexts, use -ftemplate-backtrace-limit=0 to disable ]
/usr/local/include/grppi/dyn/../seq/../common/mpmc_queue.h:438:30:   required from 'class grppi::mpmc_queue<std::pair<std::experimental::fundamentals_v1::optional<void>, long int> >'
/usr/local/include/grppi/dyn/../native/parallel_execution_native.h:1089:18:   required from 'void grppi::parallel_execution_native::do_pipeline(Queue&, Transformer&&, OtherTransformers&& ...) const [with Queue = grppi::mpmc_queue<std::pair<std::experimental::fundamentals_v1::optional<std::vector<int>*>, long int> >; Transformer = main(int, char**)::<lambda(std::vector<int>*)>; OtherTransformers = {main(int, char**)::<lambda(std::vector<int, std::allocator<int> >*)>}; typename std::enable_if<is_no_pattern<Consumer>, int>::type <anonymous> = 0]'
/usr/local/include/grppi/dyn/../native/parallel_execution_native.h:887:3:   required from 'void grppi::parallel_execution_native::pipeline(Generator&&, Transformers&& ...) const [with Generator = main(int, char**)::<lambda()>; Transformers = {main(int, char**)::<lambda(std::vector<int, std::allocator<int> >*)>, main(int, char**)::<lambda(std::vector<int, std::allocator<int> >*)>}]'
/usr/local/include/grppi/dyn/dynamic_execution.h:405:3:   required from 'void grppi::dynamic_execution::pipeline(Generator&&, Transformers&& ...) const [with Generator = main(int, char**)::<lambda()>; Transformers = {main(int, char**)::<lambda(std::vector<int, std::allocator<int> >*)>, main(int, char**)::<lambda(std::vector<int, std::allocator<int> >*)>}]'
/usr/local/include/grppi/pipeline.h:53:3:   required from 'void grppi::pipeline(const Execution&, Generator&&, Transformers&& ...) [with Execution = grppi::dynamic_execution; Generator = main(int, char**)::<lambda()>; Transformers = {main(int, char**)::<lambda(std::vector<int, std::allocator<int> >*)>, main(int, char**)::<lambda(std::vector<int, std::allocator<int> >*)>}; typename std::enable_if<is_supported<typename std::decay<_Tp>::type>(), int>::type <anonymous> = 0]'
grppi.cpp:62:9:   required from here
/usr/local/include/c++/8.3.0/experimental/optional:337:24: error: 'std::experimental::fundamentals_v1::_Optional_base<_Tp, _ShouldProvideDestructor>::<unnamed union>::_M_payload' has incomplete type
           _Stored_type _M_payload;
                        ^~~~~~~~~~
/usr/local/include/c++/8.3.0/experimental/optional:337:24: error: invalid use of 'std::experimental::fundamentals_v1::_Optional_base<void, true>::_Stored_type' {aka 'void'}
/usr/local/include/c++/8.3.0/experimental/optional: In instantiation of 'class std::experimental::fundamentals_v1::optional<void>':
/usr/local/include/c++/8.3.0/bits/stl_pair.h:214:11:   required from 'struct std::pair<std::experimental::fundamentals_v1::optional<void>, long int>'
/usr/local/include/c++/8.3.0/type_traits:920:12:   required from 'struct std::is_constructible<std::pair<std::experimental::fundamentals_v1::optional<void>, long int>, std::pair<std::experimental::fundamentals_v1::optional<void>, long int>&&>'
/usr/local/include/c++/8.3.0/type_traits:131:12:   required from 'struct std::__and_<std::is_constructible<std::pair<std::experimental::fundamentals_v1::optional<void>, long int>, std::pair<std::experimental::fundamentals_v1::optional<void>, long int>&&>, std::__is_nt_constructible_impl<std::pair<std::experimental::fundamentals_v1::optional<void>, long int>, std::pair<std::experimental::fundamentals_v1::optional<void>, long int>&&> >'
/usr/local/include/c++/8.3.0/type_traits:1005:12:   required from 'struct std::is_nothrow_constructible<std::pair<std::experimental::fundamentals_v1::optional<void>, long int>, std::pair<std::experimental::fundamentals_v1::optional<void>, long int>&&>'
/usr/local/include/c++/8.3.0/type_traits:1036:12:   required from 'struct std::__is_nothrow_move_constructible_impl<std::pair<std::experimental::fundamentals_v1::optional<void>, long int>, true>'
/usr/local/include/c++/8.3.0/type_traits:1042:12:   [ skipping 7 instantiation contexts, use -ftemplate-backtrace-limit=0 to disable ]
/usr/local/include/grppi/dyn/../seq/../common/mpmc_queue.h:438:30:   required from 'class grppi::mpmc_queue<std::pair<std::experimental::fundamentals_v1::optional<void>, long int> >'
/usr/local/include/grppi/dyn/../native/parallel_execution_native.h:1089:18:   required from 'void grppi::parallel_execution_native::do_pipeline(Queue&, Transformer&&, OtherTransformers&& ...) const [with Queue = grppi::mpmc_queue<std::pair<std::experimental::fundamentals_v1::optional<std::vector<int>*>, long int> >; Transformer = main(int, char**)::<lambda(std::vector<int>*)>; OtherTransformers = {main(int, char**)::<lambda(std::vector<int, std::allocator<int> >*)>}; typename std::enable_if<is_no_pattern<Consumer>, int>::type <anonymous> = 0]'
/usr/local/include/grppi/dyn/../native/parallel_execution_native.h:887:3:   required from 'void grppi::parallel_execution_native::pipeline(Generator&&, Transformers&& ...) const [with Generator = main(int, char**)::<lambda()>; Transformers = {main(int, char**)::<lambda(std::vector<int, std::allocator<int> >*)>, main(int, char**)::<lambda(std::vector<int, std::allocator<int> >*)>}]'
/usr/local/include/grppi/dyn/dynamic_execution.h:405:3:   required from 'void grppi::dynamic_execution::pipeline(Generator&&, Transformers&& ...) const [with Generator = main(int, char**)::<lambda()>; Transformers = {main(int, char**)::<lambda(std::vector<int, std::allocator<int> >*)>, main(int, char**)::<lambda(std::vector<int, std::allocator<int> >*)>}]'
/usr/local/include/grppi/pipeline.h:53:3:   required from 'void grppi::pipeline(const Execution&, Generator&&, Transformers&& ...) [with Execution = grppi::dynamic_execution; Generator = main(int, char**)::<lambda()>; Transformers = {main(int, char**)::<lambda(std::vector<int, std::allocator<int> >*)>, main(int, char**)::<lambda(std::vector<int, std::allocator<int> >*)>}; typename std::enable_if<is_supported<typename std::decay<_Tp>::type>(), int>::type <anonymous> = 0]'
grppi.cpp:62:9:   required from here
/usr/local/include/c++/8.3.0/experimental/optional:607:9: error: forming reference to void
         operator=(_Up&& __u)
         ^~~~~~~~
/usr/local/include/c++/8.3.0/experimental/optional:626:9: error: forming reference to void
         operator=(const optional<_Up>& __u)
         ^~~~~~~~
/usr/local/include/c++/8.3.0/experimental/optional:651:9: error: forming reference to void
         operator=(optional<_Up>&& __u)
         ^~~~~~~~
/usr/local/include/c++/8.3.0/experimental/optional:725:7: error: forming reference to void
       operator*() const&
       ^~~~~~~~
/usr/local/include/c++/8.3.0/experimental/optional:729:7: error: forming reference to void
       operator*()&
       ^~~~~~~~
/usr/local/include/c++/8.3.0/experimental/optional:733:7: error: forming reference to void
       operator*()&&
       ^~~~~~~~
/usr/local/include/c++/8.3.0/experimental/optional:737:7: error: forming reference to void
       operator*() const&&
       ^~~~~~~~
/usr/local/include/c++/8.3.0/experimental/optional:744:7: error: forming reference to void
       value() const&
       ^~~~~
/usr/local/include/c++/8.3.0/experimental/optional:754:7: error: forming reference to void
       value()&
       ^~~~~
/usr/local/include/c++/8.3.0/experimental/optional:764:7: error: forming reference to void
       value()&&
       ^~~~~
/usr/local/include/c++/8.3.0/experimental/optional:774:7: error: forming reference to void
       value() const&&
       ^~~~~
In file included from /usr/local/include/grppi/dyn/dynamic_execution.h:20,
                 from /usr/local/include/grppi/grppi.h:20,
                 from grppi.cpp:6:
/usr/local/include/grppi/dyn/../native/parallel_execution_native.h: In instantiation of 'void grppi::parallel_execution_native::do_pipeline(Queue&, Transformer&&, OtherTransformers&& ...) const [with Queue = grppi::mpmc_queue<std::pair<std::experimental::fundamentals_v1::optional<std::vector<int>*>, long int> >; Transformer = main(int, char**)::<lambda(std::vector<int>*)>; OtherTransformers = {main(int, char**)::<lambda(std::vector<int, std::allocator<int> >*)>}; typename std::enable_if<is_no_pattern<Consumer>, int>::type <anonymous> = 0]':
/usr/local/include/grppi/dyn/../native/parallel_execution_native.h:887:3:   required from 'void grppi::parallel_execution_native::pipeline(Generator&&, Transformers&& ...) const [with Generator = main(int, char**)::<lambda()>; Transformers = {main(int, char**)::<lambda(std::vector<int, std::allocator<int> >*)>, main(int, char**)::<lambda(std::vector<int, std::allocator<int> >*)>}]'
/usr/local/include/grppi/dyn/dynamic_execution.h:405:3:   required from 'void grppi::dynamic_execution::pipeline(Generator&&, Transformers&& ...) const [with Generator = main(int, char**)::<lambda()>; Transformers = {main(int, char**)::<lambda(std::vector<int, std::allocator<int> >*)>, main(int, char**)::<lambda(std::vector<int, std::allocator<int> >*)>}]'
/usr/local/include/grppi/pipeline.h:53:3:   required from 'void grppi::pipeline(const Execution&, Generator&&, Transformers&& ...) [with Execution = grppi::dynamic_execution; Generator = main(int, char**)::<lambda()>; Transformers = {main(int, char**)::<lambda(std::vector<int, std::allocator<int> >*)>, main(int, char**)::<lambda(std::vector<int, std::allocator<int> >*)>}; typename std::enable_if<is_supported<typename std::decay<_Tp>::type>(), int>::type <anonymous> = 0]'
grppi.cpp:62:9:   required from here
/usr/local/include/grppi/dyn/../native/parallel_execution_native.h:1098:12: error: no matching function for call to 'std::experimental::fundamentals_v1::optional<void>::optional(<brace-enclosed initializer list>)'
       auto out = output_item_value_type{transform_op(*item.first)};
            ^~~
In file included from grppi.cpp:4:
/usr/local/include/c++/8.3.0/experimental/optional:217:17: note: candidate: 'constexpr std::experimental::fundamentals_v1::_Optional_base<_Tp, _ShouldProvideDestructor>::_Optional_base(std::experimental::fundamentals_v1::nullopt_t) [with _Tp = void; bool _ShouldProvideDestructor = true]'
       constexpr _Optional_base(nullopt_t) noexcept
                 ^~~~~~~~~~~~~~
/usr/local/include/c++/8.3.0/experimental/optional:517:20: note:   inherited here
       using _Base::_Base;
                    ^~~~~
/usr/local/include/c++/8.3.0/experimental/optional:517:20: note:   no known conversion for argument 1 from 'void' to 'std::experimental::fundamentals_v1::nullopt_t'
/usr/local/include/c++/8.3.0/experimental/optional:222:28: note: candidate: 'template<class ... _Args> constexpr std::experimental::fundamentals_v1::_Optional_base<_Tp, _ShouldProvideDestructor>::_Optional_base(std::experimental::fundamentals_v1::in_place_t, _Args&& ...) [with _Args = {_Args ...}; _Tp = void; bool _ShouldProvideDestructor = true]'
         constexpr explicit _Optional_base(in_place_t, _Args&&... __args)
                            ^~~~~~~~~~~~~~
/usr/local/include/c++/8.3.0/experimental/optional:517:20: note:   inherited here
       using _Base::_Base;
                    ^~~~~
/usr/local/include/c++/8.3.0/experimental/optional:517:20: note:   template argument deduction/substitution failed:
In file included from /usr/local/include/grppi/dyn/dynamic_execution.h:20,
                 from /usr/local/include/grppi/grppi.h:20,
                 from grppi.cpp:6:
/usr/local/include/grppi/dyn/../native/parallel_execution_native.h:1098:53: note:   cannot convert '(& transform_op)->main(int, char**)::<lambda(std::vector<int>*)>(item.std::pair<std::experimental::fundamentals_v1::optional<std::vector<int>*>, long int>::first.std::experimental::fundamentals_v1::optional<std::vector<int>*>::operator*())' (type 'void') to type 'std::experimental::fundamentals_v1::in_place_t'
       auto out = output_item_value_type{transform_op(*item.first)};
                                         ~~~~~~~~~~~~^~~~~~~~~~~~~
In file included from grppi.cpp:4:
/usr/local/include/c++/8.3.0/experimental/optional:230:28: note: candidate: 'template<class _Up, class ... _Args, typename std::enable_if<std::is_constructible<void, std::initializer_list<_Tp>&, _Args&& ...>::value, int>::type ...<anonymous> > constexpr std::experimental::fundamentals_v1::_Optional_base<_Tp, _ShouldProvideDestructor>::_Optional_base(std::experimental::fundamentals_v1::in_place_t, std::initializer_list<_Up>, _Args&& ...) [with _Up = _Up; _Args = {_Args ...}; typename std::enable_if<std::is_constructible<_Tp, std::initializer_list<_Up>&, _Args&& ...>::value, int>::type ...<anonymous> = {<unnamed> ...}; _Tp = void; bool _ShouldProvideDestructor = true]'
         constexpr explicit _Optional_base(in_place_t,
                            ^~~~~~~~~~~~~~
/usr/local/include/c++/8.3.0/experimental/optional:517:20: note:   inherited here
       using _Base::_Base;
                    ^~~~~
/usr/local/include/c++/8.3.0/experimental/optional:517:20: note:   template argument deduction/substitution failed:
In file included from /usr/local/include/grppi/dyn/dynamic_execution.h:20,
                 from /usr/local/include/grppi/grppi.h:20,
                 from grppi.cpp:6:
/usr/local/include/grppi/dyn/../native/parallel_execution_native.h:1098:12: note:   candidate expects at least 2 arguments, 1 provided
       auto out = output_item_value_type{transform_op(*item.first)};
            ^~~
In file included from grppi.cpp:4:
/usr/local/include/c++/8.3.0/experimental/optional:237:7: note: candidate: 'std::experimental::fundamentals_v1::_Optional_base<_Tp, _ShouldProvideDestructor>::_Optional_base(const std::experimental::fundamentals_v1::_Optional_base<_Tp, _ShouldProvideDestructor>&) [with _Tp = void; bool _ShouldProvideDestructor = true]'
       _Optional_base(const _Optional_base& __other)
       ^~~~~~~~~~~~~~
/usr/local/include/c++/8.3.0/experimental/optional:517:20: note:   inherited here
       using _Base::_Base;
                    ^~~~~
/usr/local/include/c++/8.3.0/experimental/optional:517:20: note:   an inherited constructor is not a candidate for initialization from an expression of the same or derived type
/usr/local/include/c++/8.3.0/experimental/optional:243:7: note: candidate: 'std::experimental::fundamentals_v1::_Optional_base<_Tp, _ShouldProvideDestructor>::_Optional_base(std::experimental::fundamentals_v1::_Optional_base<_Tp, _ShouldProvideDestructor>&&) [with _Tp = void; bool _ShouldProvideDestructor = true]'
       _Optional_base(_Optional_base&& __other)
       ^~~~~~~~~~~~~~
/usr/local/include/c++/8.3.0/experimental/optional:517:20: note:   inherited here
       using _Base::_Base;
                    ^~~~~
/usr/local/include/c++/8.3.0/experimental/optional:517:20: note:   an inherited constructor is not a candidate for initialization from an expression of the same or derived type
/usr/local/include/c++/8.3.0/experimental/optional:585:26: note: candidate: 'template<class _Up, typename std::enable_if<std::__and_<std::__not_<std::is_same<void, _U1> >, std::is_constructible<void, _Up&&>, std::__not_<std::is_convertible<_Up&&, void> >, std::__not_<std::__or_<std::is_constructible<void, const std::experimental::fundamentals_v1::optional<_Tp>&>, std::is_constructible<void, std::experimental::fundamentals_v1::optional<_Tp>&>, std::is_constructible<void, const std::experimental::fundamentals_v1::optional<_Tp>&&>, std::is_constructible<void, std::experimental::fundamentals_v1::optional<_Tp>&&>, std::is_convertible<const std::experimental::fundamentals_v1::optional<_Tp>&, void>, std::is_convertible<std::experimental::fundamentals_v1::optional<_Tp>&, void>, std::is_convertible<const std::experimental::fundamentals_v1::optional<_Tp>&&, void>, std::is_convertible<std::experimental::fundamentals_v1::optional<_Tp>&&, void> > > >::value, bool>::type <anonymous> > constexpr std::experimental::fundamentals_v1::optional<_Tp>::optional(std::experimental::fundamentals_v1::optional<_Up>&&)'
       explicit constexpr optional(optional<_Up>&& __t)
                          ^~~~~~~~
/usr/local/include/c++/8.3.0/experimental/optional:585:26: note:   template argument deduction/substitution failed:
In file included from /usr/local/include/grppi/dyn/dynamic_execution.h:20,
                 from /usr/local/include/grppi/grppi.h:20,
                 from grppi.cpp:6:
/usr/local/include/grppi/dyn/../native/parallel_execution_native.h:1098:12: note:   mismatched types 'std::experimental::fundamentals_v1::optional<_Tp>' and 'void'
       auto out = output_item_value_type{transform_op(*item.first)};
            ^~~
In file included from grppi.cpp:4:
/usr/local/include/c++/8.3.0/experimental/optional:572:17: note: candidate: 'template<class _Up, typename std::enable_if<std::__and_<std::__not_<std::is_same<void, _U1> >, std::is_constructible<void, _Up&&>, std::is_convertible<_Up&&, void>, std::__not_<std::__or_<std::is_constructible<void, const std::experimental::fundamentals_v1::optional<_Tp>&>, std::is_constructible<void, std::experimental::fundamentals_v1::optional<_Tp>&>, std::is_constructible<void, const std::experimental::fundamentals_v1::optional<_Tp>&&>, std::is_constructible<void, std::experimental::fundamentals_v1::optional<_Tp>&&>, std::is_convertible<const std::experimental::fundamentals_v1::optional<_Tp>&, void>, std::is_convertible<std::experimental::fundamentals_v1::optional<_Tp>&, void>, std::is_convertible<const std::experimental::fundamentals_v1::optional<_Tp>&&, void>, std::is_convertible<std::experimental::fundamentals_v1::optional<_Tp>&&, void> > > >::value, bool>::type <anonymous> > constexpr std::experimental::fundamentals_v1::optional<_Tp>::optional(std::experimental::fundamentals_v1::optional<_Up>&&)'
       constexpr optional(optional<_Up>&& __t)
                 ^~~~~~~~
/usr/local/include/c++/8.3.0/experimental/optional:572:17: note:   template argument deduction/substitution failed:
In file included from /usr/local/include/grppi/dyn/dynamic_execution.h:20,
                 from /usr/local/include/grppi/grppi.h:20,
                 from grppi.cpp:6:
/usr/local/include/grppi/dyn/../native/parallel_execution_native.h:1098:12: note:   mismatched types 'std::experimental::fundamentals_v1::optional<_Tp>' and 'void'
       auto out = output_item_value_type{transform_op(*item.first)};
            ^~~
In file included from grppi.cpp:4:
/usr/local/include/c++/8.3.0/experimental/optional:559:26: note: candidate: 'template<class _Up, typename std::enable_if<std::__and_<std::__not_<std::is_same<void, _U1> >, std::is_constructible<void, const _Up&>, std::__not_<std::is_convertible<const _Up&, void> >, std::__not_<std::__or_<std::is_constructible<void, const std::experimental::fundamentals_v1::optional<_Tp>&>, std::is_constructible<void, std::experimental::fundamentals_v1::optional<_Tp>&>, std::is_constructible<void, const std::experimental::fundamentals_v1::optional<_Tp>&&>, std::is_constructible<void, std::experimental::fundamentals_v1::optional<_Tp>&&>, std::is_convertible<const std::experimental::fundamentals_v1::optional<_Tp>&, void>, std::is_convertible<std::experimental::fundamentals_v1::optional<_Tp>&, void>, std::is_convertible<const std::experimental::fundamentals_v1::optional<_Tp>&&, void>, std::is_convertible<std::experimental::fundamentals_v1::optional<_Tp>&&, void> > > >::value, bool>::type <anonymous> > constexpr std::experimental::fundamentals_v1::optional<_Tp>::optional(const std::experimental::fundamentals_v1::optional<_Up>&)'
       explicit constexpr optional(const optional<_Up>& __t)
                          ^~~~~~~~
/usr/local/include/c++/8.3.0/experimental/optional:559:26: note:   template argument deduction/substitution failed:
In file included from /usr/local/include/grppi/dyn/dynamic_execution.h:20,
                 from /usr/local/include/grppi/grppi.h:20,
                 from grppi.cpp:6:
/usr/local/include/grppi/dyn/../native/parallel_execution_native.h:1098:12: note:   mismatched types 'const std::experimental::fundamentals_v1::optional<_Tp>' and 'void'
       auto out = output_item_value_type{transform_op(*item.first)};
            ^~~
In file included from grppi.cpp:4:
/usr/local/include/c++/8.3.0/experimental/optional:546:17: note: candidate: 'template<class _Up, typename std::enable_if<std::__and_<std::__not_<std::is_same<void, _U1> >, std::is_constructible<void, const _Up&>, std::is_convertible<const _Up&, void>, std::__not_<std::__or_<std::is_constructible<void, const std::experimental::fundamentals_v1::optional<_Tp>&>, std::is_constructible<void, std::experimental::fundamentals_v1::optional<_Tp>&>, std::is_constructible<void, const std::experimental::fundamentals_v1::optional<_Tp>&&>, std::is_constructible<void, std::experimental::fundamentals_v1::optional<_Tp>&&>, std::is_convertible<const std::experimental::fundamentals_v1::optional<_Tp>&, void>, std::is_convertible<std::experimental::fundamentals_v1::optional<_Tp>&, void>, std::is_convertible<const std::experimental::fundamentals_v1::optional<_Tp>&&, void>, std::is_convertible<std::experimental::fundamentals_v1::optional<_Tp>&&, void> > > >::value, bool>::type <anonymous> > constexpr std::experimental::fundamentals_v1::optional<_Tp>::optional(const std::experimental::fundamentals_v1::optional<_Up>&)'
       constexpr optional(const optional<_Up>& __t)
                 ^~~~~~~~
/usr/local/include/c++/8.3.0/experimental/optional:546:17: note:   template argument deduction/substitution failed:
In file included from /usr/local/include/grppi/dyn/dynamic_execution.h:20,
                 from /usr/local/include/grppi/grppi.h:20,
                 from grppi.cpp:6:
/usr/local/include/grppi/dyn/../native/parallel_execution_native.h:1098:12: note:   mismatched types 'const std::experimental::fundamentals_v1::optional<_Tp>' and 'void'
       auto out = output_item_value_type{transform_op(*item.first)};
            ^~~
In file included from grppi.cpp:4:
/usr/local/include/c++/8.3.0/experimental/optional:536:26: note: candidate: 'template<class _Up, typename std::enable_if<std::__and_<std::__not_<std::is_same<std::experimental::fundamentals_v1::optional<void>, typename std::decay<_Tp>::type> >, std::is_constructible<void, _Up&&>, std::__not_<std::is_convertible<_Up&&, void> > >::value, bool>::type <anonymous> > constexpr std::experimental::fundamentals_v1::optional<_Tp>::optional(_Up&&)'
       explicit constexpr optional(_Up&& __t)
                          ^~~~~~~~
/usr/local/include/c++/8.3.0/experimental/optional:536:26: note:   template argument deduction/substitution failed:
/usr/local/include/c++/8.3.0/experimental/optional:535:28: error: forming reference to void
          >::value, bool> = false>
                            ^~~~~
/usr/local/include/c++/8.3.0/experimental/optional:527:17: note: candidate: 'template<class _Up, typename std::enable_if<std::__and_<std::__not_<std::is_same<std::experimental::fundamentals_v1::optional<void>, typename std::decay<_Tp>::type> >, std::is_constructible<void, _Up&&>, std::is_convertible<_Up&&, void> >::value, bool>::type <anonymous> > constexpr std::experimental::fundamentals_v1::optional<_Tp>::optional(_Up&&)'
       constexpr optional(_Up&& __t)
                 ^~~~~~~~
/usr/local/include/c++/8.3.0/experimental/optional:527:17: note:   template argument deduction/substitution failed:
/usr/local/include/c++/8.3.0/experimental/optional:526:28: error: forming reference to void
          >::value, bool> = true>
                            ^~~~
/usr/local/include/c++/8.3.0/experimental/optional:519:17: note: candidate: 'constexpr std::experimental::fundamentals_v1::optional<_Tp>::optional() [with _Tp = void]'
       constexpr optional() = default;
                 ^~~~~~~~
/usr/local/include/c++/8.3.0/experimental/optional:519:17: note:   candidate expects 0 arguments, 1 provided
In file included from /usr/local/include/grppi/dyn/dynamic_execution.h:20,
                 from /usr/local/include/grppi/grppi.h:20,
                 from grppi.cpp:6:
/usr/local/include/grppi/dyn/../native/parallel_execution_native.h:1101:5: error: no matching function for call to 'grppi::mpmc_queue<std::pair<std::experimental::fundamentals_v1::optional<void>, long int> >::push(std::pair<std::experimental::fundamentals_v1::optional<void>, int>)'
     output_queue.push(make_pair(output_item_value_type{},-1));
     ^~~~~~~~~~~~
In file included from /usr/local/include/grppi/dyn/../seq/sequential_execution.h:19,
                 from /usr/local/include/grppi/dyn/dynamic_execution.h:19,
                 from /usr/local/include/grppi/grppi.h:20,
                 from grppi.cpp:6:
/usr/local/include/grppi/dyn/../seq/../common/mpmc_queue.h:367:8: note: candidate: 'void grppi::mpmc_queue<T>::push(T&&) [with T = std::pair<std::experimental::fundamentals_v1::optional<void>, long int>]'
   void push (T && item) noexcept(std::is_nothrow_move_assignable<T>::value) {
        ^~~~
/usr/local/include/grppi/dyn/../seq/../common/mpmc_queue.h:367:8: note:   no known conversion for argument 1 from 'std::pair<std::experimental::fundamentals_v1::optional<void>, int>' to 'std::pair<std::experimental::fundamentals_v1::optional<void>, long int>&&'
/usr/local/include/grppi/dyn/../seq/../common/mpmc_queue.h:376:8: note: candidate: 'void grppi::mpmc_queue<T>::push(const T&) [with T = std::pair<std::experimental::fundamentals_v1::optional<void>, long int>]'
   void push (T const & item) noexcept(std::is_nothrow_copy_assignable<T>::value) {
        ^~~~
/usr/local/include/grppi/dyn/../seq/../common/mpmc_queue.h:376:8: note:   no known conversion for argument 1 from 'std::pair<std::experimental::fundamentals_v1::optional<void>, int>' to 'const std::pair<std::experimental::fundamentals_v1::optional<void>, long int>&'
In file included from /usr/local/include/c++/8.3.0/bits/stl_algobase.h:64,
                 from /usr/local/include/c++/8.3.0/bits/char_traits.h:39,
                 from /usr/local/include/c++/8.3.0/ios:40,
                 from /usr/local/include/c++/8.3.0/ostream:38,
                 from /usr/local/include/c++/8.3.0/iostream:39,
                 from grppi.cpp:1:
/usr/local/include/c++/8.3.0/bits/stl_pair.h: In instantiation of 'constexpr std::pair<typename std::__decay_and_strip<_Tp>::__type, typename std::__decay_and_strip<_T2>::__type> std::make_pair(_T1&&, _T2&&) [with _T1 = std::experimental::fundamentals_v1::optional<void>; _T2 = int; typename std::__decay_and_strip<_T2>::__type = int; typename std::__decay_and_strip<_Tp>::__type = std::experimental::fundamentals_v1::optional<void>]':
/usr/local/include/grppi/dyn/../native/parallel_execution_native.h:1101:32:   required from 'void grppi::parallel_execution_native::do_pipeline(Queue&, Transformer&&, OtherTransformers&& ...) const [with Queue = grppi::mpmc_queue<std::pair<std::experimental::fundamentals_v1::optional<std::vector<int>*>, long int> >; Transformer = main(int, char**)::<lambda(std::vector<int>*)>; OtherTransformers = {main(int, char**)::<lambda(std::vector<int, std::allocator<int> >*)>}; typename std::enable_if<is_no_pattern<Consumer>, int>::type <anonymous> = 0]'
/usr/local/include/grppi/dyn/../native/parallel_execution_native.h:887:3:   required from 'void grppi::parallel_execution_native::pipeline(Generator&&, Transformers&& ...) const [with Generator = main(int, char**)::<lambda()>; Transformers = {main(int, char**)::<lambda(std::vector<int, std::allocator<int> >*)>, main(int, char**)::<lambda(std::vector<int, std::allocator<int> >*)>}]'
/usr/local/include/grppi/dyn/dynamic_execution.h:405:3:   required from 'void grppi::dynamic_execution::pipeline(Generator&&, Transformers&& ...) const [with Generator = main(int, char**)::<lambda()>; Transformers = {main(int, char**)::<lambda(std::vector<int, std::allocator<int> >*)>, main(int, char**)::<lambda(std::vector<int, std::allocator<int> >*)>}]'
/usr/local/include/grppi/pipeline.h:53:3:   required from 'void grppi::pipeline(const Execution&, Generator&&, Transformers&& ...) [with Execution = grppi::dynamic_execution; Generator = main(int, char**)::<lambda()>; Transformers = {main(int, char**)::<lambda(std::vector<int, std::allocator<int> >*)>, main(int, char**)::<lambda(std::vector<int, std::allocator<int> >*)>}; typename std::enable_if<is_supported<typename std::decay<_Tp>::type>(), int>::type <anonymous> = 0]'
grppi.cpp:62:9:   required from here
/usr/local/include/c++/8.3.0/bits/stl_pair.h:529:14: error: no matching function for call to 'std::pair<std::experimental::fundamentals_v1::optional<void>, int>::pair(std::experimental::fundamentals_v1::optional<void>, int)'
       return __pair_type(std::forward<_T1>(__x), std::forward<_T2>(__y));
              ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
/usr/local/include/c++/8.3.0/bits/stl_pair.h:436:9: note: candidate: 'template<class ... _Args1, long unsigned int ..._Indexes1, class ... _Args2, long unsigned int ..._Indexes2> std::pair<_T1, _T2>::pair(std::tuple<_Args1 ...>&, std::tuple<_Args2 ...>&, std::_Index_tuple<_Indexes1 ...>, std::_Index_tuple<_Indexes2 ...>)'
         pair(tuple<_Args1...>&, tuple<_Args2...>&,
         ^~~~
/usr/local/include/c++/8.3.0/bits/stl_pair.h:436:9: note:   template argument deduction/substitution failed:
/usr/local/include/c++/8.3.0/bits/stl_pair.h:529:14: note:   'std::experimental::fundamentals_v1::optional<void>' is not derived from 'std::tuple<_Tps ...>'
       return __pair_type(std::forward<_T1>(__x), std::forward<_T2>(__y));
              ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
/usr/local/include/c++/8.3.0/bits/stl_pair.h:375:9: note: candidate: 'template<class ... _Args1, class ... _Args2> std::pair<_T1, _T2>::pair(std::piecewise_construct_t, std::tuple<_Args1 ...>, std::tuple<_Args2 ...>)'
         pair(piecewise_construct_t, tuple<_Args1...>, tuple<_Args2...>);
         ^~~~
/usr/local/include/c++/8.3.0/bits/stl_pair.h:375:9: note:   template argument deduction/substitution failed:
/usr/local/include/c++/8.3.0/bits/stl_pair.h:529:14: note:   mismatched types 'std::tuple<_Tps ...>' and 'int'
       return __pair_type(std::forward<_T1>(__x), std::forward<_T2>(__y));
              ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
/usr/local/include/c++/8.3.0/bits/stl_pair.h:370:21: note: candidate: 'template<class _U1, class _U2, typename std::enable_if<(std::_PCC<((! std::is_same<std::experimental::fundamentals_v1::optional<void>, _U1>::value) || (! std::is_same<int, _U2>::value)), std::experimental::fundamentals_v1::optional<void>, int>::_MoveConstructiblePair<_U1, _U2>() && (! std::_PCC<((! std::is_same<std::experimental::fundamentals_v1::optional<void>, _U1>::value) || (! std::is_same<int, _U2>::value)), std::experimental::fundamentals_v1::optional<void>, int>::_ImplicitlyMoveConvertiblePair<_U1, _U2>())), bool>::type <anonymous> > constexpr std::pair<_T1, _T2>::pair(std::pair<_U1, _U2>&&)'
  explicit constexpr pair(pair<_U1, _U2>&& __p)
                     ^~~~
/usr/local/include/c++/8.3.0/bits/stl_pair.h:370:21: note:   template argument deduction/substitution failed:
/usr/local/include/c++/8.3.0/bits/stl_pair.h:529:14: note:   'std::experimental::fundamentals_v1::optional<void>' is not derived from 'std::pair<_T1, _T2>'
       return __pair_type(std::forward<_T1>(__x), std::forward<_T2>(__y));
              ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
/usr/local/include/c++/8.3.0/bits/stl_pair.h:360:12: note: candidate: 'template<class _U1, class _U2, typename std::enable_if<(std::_PCC<((! std::is_same<std::experimental::fundamentals_v1::optional<void>, _U1>::value) || (! std::is_same<int, _U2>::value)), std::experimental::fundamentals_v1::optional<void>, int>::_MoveConstructiblePair<_U1, _U2>() && std::_PCC<((! std::is_same<std::experimental::fundamentals_v1::optional<void>, _U1>::value) || (! std::is_same<int, _U2>::value)), std::experimental::fundamentals_v1::optional<void>, int>::_ImplicitlyMoveConvertiblePair<_U1, _U2>()), bool>::type <anonymous> > constexpr std::pair<_T1, _T2>::pair(std::pair<_U1, _U2>&&)'
  constexpr pair(pair<_U1, _U2>&& __p)
            ^~~~
/usr/local/include/c++/8.3.0/bits/stl_pair.h:360:12: note:   template argument deduction/substitution failed:
/usr/local/include/c++/8.3.0/bits/stl_pair.h:529:14: note:   'std::experimental::fundamentals_v1::optional<void>' is not derived from 'std::pair<_T1, _T2>'
       return __pair_type(std::forward<_T1>(__x), std::forward<_T2>(__y));
              ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
/usr/local/include/c++/8.3.0/bits/stl_pair.h:350:21: note: candidate: 'template<class _U1, class _U2, typename std::enable_if<(_MoveConstructiblePair<_U1, _U2>() && (! _ImplicitlyMoveConvertiblePair<_U1, _U2>())), bool>::type <anonymous> > constexpr std::pair<_T1, _T2>::pair(_U1&&, _U2&&)'
  explicit constexpr pair(_U1&& __x, _U2&& __y)
                     ^~~~
/usr/local/include/c++/8.3.0/bits/stl_pair.h:350:21: note:   template argument deduction/substitution failed:
/usr/local/include/c++/8.3.0/bits/stl_pair.h:349:38: error: no type named 'type' in 'struct std::enable_if<false, bool>'
                          bool>::type=false>
                                      ^~~~~
/usr/local/include/c++/8.3.0/bits/stl_pair.h:341:12: note: candidate: 'template<class _U1, class _U2, typename std::enable_if<(_MoveConstructiblePair<_U1, _U2>() && _ImplicitlyMoveConvertiblePair<_U1, _U2>()), bool>::type <anonymous> > constexpr std::pair<_T1, _T2>::pair(_U1&&, _U2&&)'
  constexpr pair(_U1&& __x, _U2&& __y)
            ^~~~
/usr/local/include/c++/8.3.0/bits/stl_pair.h:341:12: note:   template argument deduction/substitution failed:
/usr/local/include/c++/8.3.0/bits/stl_pair.h:340:38: error: no type named 'type' in 'struct std::enable_if<false, bool>'
                          bool>::type=true>
                                      ^~~~
/usr/local/include/c++/8.3.0/bits/stl_pair.h:332:17: note: candidate: 'template<class _U2, typename std::enable_if<_CopyMovePair<false, std::experimental::fundamentals_v1::optional<void>, _U2>(), bool>::type <anonymous> > std::pair<_T1, _T2>::pair(const _T1&, _U2&&)'
        explicit pair(const _T1& __x, _U2&& __y)
                 ^~~~
/usr/local/include/c++/8.3.0/bits/stl_pair.h:332:17: note:   template argument deduction/substitution failed:
/usr/local/include/c++/8.3.0/bits/stl_pair.h:331:38: error: no type named 'type' in 'struct std::enable_if<false, bool>'
                          bool>::type=false>
                                      ^~~~~
/usr/local/include/c++/8.3.0/bits/stl_pair.h:325:18: note: candidate: 'template<class _U2, typename std::enable_if<_CopyMovePair<true, std::experimental::fundamentals_v1::optional<void>, _U2>(), bool>::type <anonymous> > constexpr std::pair<_T1, _T2>::pair(const _T1&, _U2&&)'
        constexpr pair(const _T1& __x, _U2&& __y)
                  ^~~~
/usr/local/include/c++/8.3.0/bits/stl_pair.h:325:18: note:   template argument deduction/substitution failed:
/usr/local/include/c++/8.3.0/bits/stl_pair.h:324:38: error: no type named 'type' in 'struct std::enable_if<false, bool>'
                          bool>::type=true>
                                      ^~~~
/usr/local/include/c++/8.3.0/bits/stl_pair.h:318:27: note: candidate: 'template<class _U1, typename std::enable_if<_MoveCopyPair<false, _U1, int>(), bool>::type <anonymous> > constexpr std::pair<_T1, _T2>::pair(_U1&&, const _T2&)'
        explicit constexpr pair(_U1&& __x, const _T2& __y)
                           ^~~~
/usr/local/include/c++/8.3.0/bits/stl_pair.h:318:27: note:   template argument deduction/substitution failed:
/usr/local/include/c++/8.3.0/bits/stl_pair.h:317:38: error: no type named 'type' in 'struct std::enable_if<false, bool>'
                          bool>::type=false>
                                      ^~~~~
/usr/local/include/c++/8.3.0/bits/stl_pair.h:311:18: note: candidate: 'template<class _U1, typename std::enable_if<_MoveCopyPair<true, _U1, int>(), bool>::type <anonymous> > constexpr std::pair<_T1, _T2>::pair(_U1&&, const _T2&)'
        constexpr pair(_U1&& __x, const _T2& __y)
                  ^~~~
/usr/local/include/c++/8.3.0/bits/stl_pair.h:311:18: note:   template argument deduction/substitution failed:
/usr/local/include/c++/8.3.0/bits/stl_pair.h:310:38: error: no type named 'type' in 'struct std::enable_if<false, bool>'
                          bool>::type=true>
                                      ^~~~
/usr/local/include/c++/8.3.0/bits/stl_pair.h:300:21: note: candidate: 'template<class _U1, class _U2, typename std::enable_if<(std::_PCC<((! std::is_same<std::experimental::fundamentals_v1::optional<void>, _U1>::value) || (! std::is_same<int, _U2>::value)), std::experimental::fundamentals_v1::optional<void>, int>::_ConstructiblePair<_U1, _U2>() && (! std::_PCC<((! std::is_same<std::experimental::fundamentals_v1::optional<void>, _U1>::value) || (! std::is_same<int, _U2>::value)), std::experimental::fundamentals_v1::optional<void>, int>::_ImplicitlyConvertiblePair<_U1, _U2>())), bool>::type <anonymous> > constexpr std::pair<_T1, _T2>::pair(const std::pair<_U1, _U2>&)'
  explicit constexpr pair(const pair<_U1, _U2>& __p)
                     ^~~~
/usr/local/include/c++/8.3.0/bits/stl_pair.h:300:21: note:   template argument deduction/substitution failed:
/usr/local/include/c++/8.3.0/bits/stl_pair.h:529:14: note:   'std::experimental::fundamentals_v1::optional<void>' is not derived from 'const std::pair<_T1, _T2>'
       return __pair_type(std::forward<_T1>(__x), std::forward<_T2>(__y));
              ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
/usr/local/include/c++/8.3.0/bits/stl_pair.h:291:19: note: candidate: 'template<class _U1, class _U2, typename std::enable_if<(std::_PCC<((! std::is_same<std::experimental::fundamentals_v1::optional<void>, _U1>::value) || (! std::is_same<int, _U2>::value)), std::experimental::fundamentals_v1::optional<void>, int>::_ConstructiblePair<_U1, _U2>() && std::_PCC<((! std::is_same<std::experimental::fundamentals_v1::optional<void>, _U1>::value) || (! std::is_same<int, _U2>::value)), std::experimental::fundamentals_v1::optional<void>, int>::_ImplicitlyConvertiblePair<_U1, _U2>()), bool>::type <anonymous> > constexpr std::pair<_T1, _T2>::pair(const std::pair<_U1, _U2>&)'
         constexpr pair(const pair<_U1, _U2>& __p)
                   ^~~~
/usr/local/include/c++/8.3.0/bits/stl_pair.h:291:19: note:   template argument deduction/substitution failed:
/usr/local/include/c++/8.3.0/bits/stl_pair.h:529:14: note:   'std::experimental::fundamentals_v1::optional<void>' is not derived from 'const std::pair<_T1, _T2>'
       return __pair_type(std::forward<_T1>(__x), std::forward<_T2>(__y));
              ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
/usr/local/include/c++/8.3.0/bits/stl_pair.h:269:26: note: candidate: 'template<class _U1, class _U2, typename std::enable_if<(_ConstructiblePair<_U1, _U2>() && (! _ImplicitlyConvertiblePair<_U1, _U2>())), bool>::type <anonymous> > constexpr std::pair<_T1, _T2>::pair(const _T1&, const _T2&)'
       explicit constexpr pair(const _T1& __a, const _T2& __b)
                          ^~~~
/usr/local/include/c++/8.3.0/bits/stl_pair.h:269:26: note:   template argument deduction/substitution failed:
/usr/local/include/c++/8.3.0/bits/stl_pair.h:268:38: error: no type named 'type' in 'struct std::enable_if<false, bool>'
                          bool>::type=false>
                                      ^~~~~
/usr/local/include/c++/8.3.0/bits/stl_pair.h:260:17: note: candidate: 'template<class _U1, class _U2, typename std::enable_if<(_ConstructiblePair<_U1, _U2>() && _ImplicitlyConvertiblePair<_U1, _U2>()), bool>::type <anonymous> > constexpr std::pair<_T1, _T2>::pair(const _T1&, const _T2&)'
       constexpr pair(const _T1& __a, const _T2& __b)
                 ^~~~
/usr/local/include/c++/8.3.0/bits/stl_pair.h:260:17: note:   template argument deduction/substitution failed:
/usr/local/include/c++/8.3.0/bits/stl_pair.h:259:38: error: no type named 'type' in 'struct std::enable_if<false, bool>'
                          bool>::type=true>
                                      ^~~~
/usr/local/include/c++/8.3.0/bits/stl_pair.h:242:26: note: candidate: 'template<class _U1, class _U2, typename std::enable_if<std::__and_<std::is_default_constructible<_Tp>, std::is_default_constructible<_Dp>, std::__not_<std::__and_<std::__is_implicitly_default_constructible<_U1>, std::__is_implicitly_default_constructible<_U2> > > >::value, bool>::type <anonymous> > constexpr std::pair<_T1, _T2>::pair()'
       explicit constexpr pair()
                          ^~~~
/usr/local/include/c++/8.3.0/bits/stl_pair.h:242:26: note:   template argument deduction/substitution failed:
/usr/local/include/c++/8.3.0/bits/stl_pair.h:529:14: note:   candidate expects 0 arguments, 2 provided
       return __pair_type(std::forward<_T1>(__x), std::forward<_T2>(__y));
              ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
/usr/local/include/c++/8.3.0/bits/stl_pair.h:229:26: note: candidate: 'template<class _U1, class _U2, typename std::enable_if<std::__and_<std::__is_implicitly_default_constructible<_U1>, std::__is_implicitly_default_constructible<_U2> >::value, bool>::type <anonymous> > constexpr std::pair<_T1, _T2>::pair()'
       _GLIBCXX_CONSTEXPR pair()
                          ^~~~
/usr/local/include/c++/8.3.0/bits/stl_pair.h:229:26: note:   template argument deduction/substitution failed:
/usr/local/include/c++/8.3.0/bits/stl_pair.h:529:14: note:   candidate expects 0 arguments, 2 provided
       return __pair_type(std::forward<_T1>(__x), std::forward<_T2>(__y));
              ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
In file included from /usr/local/include/grppi/dyn/../seq/sequential_execution.h:19,
                 from /usr/local/include/grppi/dyn/dynamic_execution.h:19,
                 from /usr/local/include/grppi/grppi.h:20,
                 from grppi.cpp:6:
/usr/local/include/grppi/dyn/../seq/../common/mpmc_queue.h: In instantiation of 'T grppi::mpmc_queue<T>::concrete_queue<Q>::pop() [with Q = grppi::atomic_mpmc_queue<std::pair<std::experimental::fundamentals_v1::optional<void>, long int> >; T = std::pair<std::experimental::fundamentals_v1::optional<void>, long int>]':
/usr/local/include/grppi/dyn/../seq/../common/mpmc_queue.h:405:7:   required from here
/usr/local/include/grppi/dyn/../seq/../common/mpmc_queue.h:406:27: error: use of deleted function 'constexpr std::pair<_T1, _T2>::pair(std::pair<_T1, _T2>&&) [with _T1 = std::experimental::fundamentals_v1::optional<void>; _T2 = long int]'
       { return queue_.pop(); }
                           ^
In file included from /usr/local/include/c++/8.3.0/bits/stl_algobase.h:64,
                 from /usr/local/include/c++/8.3.0/bits/char_traits.h:39,
                 from /usr/local/include/c++/8.3.0/ios:40,
                 from /usr/local/include/c++/8.3.0/ostream:38,
                 from /usr/local/include/c++/8.3.0/iostream:39,
                 from grppi.cpp:1:
/usr/local/include/c++/8.3.0/bits/stl_pair.h:304:17: note: 'constexpr std::pair<_T1, _T2>::pair(std::pair<_T1, _T2>&&) [with _T1 = std::experimental::fundamentals_v1::optional<void>; _T2 = long int]' is implicitly deleted because the default definition would be ill-formed:
       constexpr pair(pair&&) = default;
                 ^~~~
/usr/local/include/c++/8.3.0/bits/stl_pair.h:304:17: error: use of deleted function 'std::experimental::fundamentals_v1::optional<void>::optional(std::experimental::fundamentals_v1::optional<void>&&)'
In file included from grppi.cpp:4:
/usr/local/include/c++/8.3.0/experimental/optional:491:11: note: 'std::experimental::fundamentals_v1::optional<void>::optional(std::experimental::fundamentals_v1::optional<void>&&)' is implicitly deleted because the default definition would be ill-formed:
     class optional
           ^~~~~~~~
/usr/local/include/c++/8.3.0/experimental/optional:491:11: error: use of deleted function 'constexpr std::_Enable_copy_move<false, false, false, false, _Tag>::_Enable_copy_move(std::_Enable_copy_move<false, false, false, false, _Tag>&&) [with _Tag = std::experimental::fundamentals_v1::optional<void>]'
In file included from /usr/local/include/c++/8.3.0/experimental/optional:53,
                 from grppi.cpp:4:
/usr/local/include/c++/8.3.0/bits/enable_special_members.h:302:15: note: declared here
     constexpr _Enable_copy_move(_Enable_copy_move&&) noexcept       = delete;
               ^~~~~~~~~~~~~~~~~
In file included from /usr/local/include/grppi/dyn/../seq/sequential_execution.h:19,
                 from /usr/local/include/grppi/dyn/dynamic_execution.h:19,
                 from /usr/local/include/grppi/grppi.h:20,
                 from grppi.cpp:6:
/usr/local/include/grppi/dyn/../seq/../common/mpmc_queue.h: In instantiation of 'T grppi::atomic_mpmc_queue<T>::pop() [with T = std::pair<std::experimental::fundamentals_v1::optional<void>, long int>]':
/usr/local/include/grppi/dyn/../seq/../common/mpmc_queue.h:406:27:   required from 'T grppi::mpmc_queue<T>::concrete_queue<Q>::pop() [with Q = grppi::atomic_mpmc_queue<std::pair<std::experimental::fundamentals_v1::optional<void>, long int> >; T = std::pair<std::experimental::fundamentals_v1::optional<void>, long int>]'
/usr/local/include/grppi/dyn/../seq/../common/mpmc_queue.h:405:7:   required from here
/usr/local/include/grppi/dyn/../seq/../common/mpmc_queue.h:132:8: error: use of deleted function 'constexpr std::pair<_T1, _T2>::pair(std::pair<_T1, _T2>&&) [with _T1 = std::experimental::fundamentals_v1::optional<void>; _T2 = long int]'
   auto item = std::move(buffer_[current%size_]);
        ^~~~
/usr/local/include/grppi/dyn/../seq/../common/mpmc_queue.h:139:10: error: use of deleted function 'constexpr std::pair<_T1, _T2>::pair(const std::pair<_T1, _T2>&) [with _T1 = std::experimental::fundamentals_v1::optional<void>; _T2 = long int]'
   return item;
          ^~~~
In file included from /usr/local/include/c++/8.3.0/bits/stl_algobase.h:64,
                 from /usr/local/include/c++/8.3.0/bits/char_traits.h:39,
                 from /usr/local/include/c++/8.3.0/ios:40,
                 from /usr/local/include/c++/8.3.0/ostream:38,
                 from /usr/local/include/c++/8.3.0/iostream:39,
                 from grppi.cpp:1:
/usr/local/include/c++/8.3.0/bits/stl_pair.h:303:17: note: 'constexpr std::pair<_T1, _T2>::pair(const std::pair<_T1, _T2>&) [with _T1 = std::experimental::fundamentals_v1::optional<void>; _T2 = long int]' is implicitly deleted because the default definition would be ill-formed:
       constexpr pair(const pair&) = default;
                 ^~~~
/usr/local/include/c++/8.3.0/bits/stl_pair.h:303:17: error: use of deleted function 'std::experimental::fundamentals_v1::optional<void>::optional(const std::experimental::fundamentals_v1::optional<void>&)'
In file included from grppi.cpp:4:
/usr/local/include/c++/8.3.0/experimental/optional:491:11: note: 'std::experimental::fundamentals_v1::optional<void>::optional(const std::experimental::fundamentals_v1::optional<void>&)' is implicitly deleted because the default definition would be ill-formed:
     class optional
           ^~~~~~~~
/usr/local/include/c++/8.3.0/experimental/optional:491:11: error: use of deleted function 'constexpr std::_Enable_copy_move<false, false, false, false, _Tag>::_Enable_copy_move(const std::_Enable_copy_move<false, false, false, false, _Tag>&) [with _Tag = std::experimental::fundamentals_v1::optional<void>]'
In file included from /usr/local/include/c++/8.3.0/experimental/optional:53,
                 from grppi.cpp:4:
/usr/local/include/c++/8.3.0/bits/enable_special_members.h:301:15: note: declared here
     constexpr _Enable_copy_move(_Enable_copy_move const&) noexcept  = delete;
               ^~~~~~~~~~~~~~~~~
In file included from /usr/local/include/grppi/dyn/../seq/sequential_execution.h:19,
                 from /usr/local/include/grppi/dyn/dynamic_execution.h:19,
                 from /usr/local/include/grppi/grppi.h:20,
                 from grppi.cpp:6:
/usr/local/include/grppi/dyn/../seq/../common/mpmc_queue.h: In instantiation of 'void grppi::atomic_mpmc_queue<T>::push(T&&) [with T = std::pair<std::experimental::fundamentals_v1::optional<void>, long int>]':
/usr/local/include/grppi/dyn/../seq/../common/mpmc_queue.h:408:9:   required from 'void grppi::mpmc_queue<T>::concrete_queue<Q>::push(T&&) [with Q = grppi::atomic_mpmc_queue<std::pair<std::experimental::fundamentals_v1::optional<void>, long int> >; T = std::pair<std::experimental::fundamentals_v1::optional<void>, long int>]'
/usr/local/include/grppi/dyn/../seq/../common/mpmc_queue.h:407:10:   required from here
/usr/local/include/grppi/dyn/../seq/../common/mpmc_queue.h:152:26: error: use of deleted function 'std::pair<std::experimental::fundamentals_v1::optional<void>, long int>& std::pair<std::experimental::fundamentals_v1::optional<void>, long int>::operator=(const std::pair<std::experimental::fundamentals_v1::optional<void>, long int>&)'
   buffer_[current%size_] = std::move(item);
   ~~~~~~~~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~
In file included from /usr/local/include/c++/8.3.0/bits/stl_algobase.h:64,
                 from /usr/local/include/c++/8.3.0/bits/char_traits.h:39,
                 from /usr/local/include/c++/8.3.0/ios:40,
                 from /usr/local/include/c++/8.3.0/ostream:38,
                 from /usr/local/include/c++/8.3.0/iostream:39,
                 from grppi.cpp:1:
/usr/local/include/c++/8.3.0/bits/stl_pair.h:208:12: note: 'std::pair<std::experimental::fundamentals_v1::optional<void>, long int>& std::pair<std::experimental::fundamentals_v1::optional<void>, long int>::operator=(const std::pair<std::experimental::fundamentals_v1::optional<void>, long int>&)' is implicitly declared as deleted because 'std::pair<std::experimental::fundamentals_v1::optional<void>, long int>' declares a move constructor or move assignment operator
     struct pair
            ^~~~
In file included from /usr/local/include/grppi/dyn/../seq/sequential_execution.h:19,
                 from /usr/local/include/grppi/dyn/dynamic_execution.h:19,
                 from /usr/local/include/grppi/grppi.h:20,
                 from grppi.cpp:6:
/usr/local/include/grppi/dyn/../seq/../common/mpmc_queue.h: In instantiation of 'void grppi::atomic_mpmc_queue<T>::push(const T&) [with T = std::pair<std::experimental::fundamentals_v1::optional<void>, long int>]':
/usr/local/include/grppi/dyn/../seq/../common/mpmc_queue.h:410:9:   required from 'void grppi::mpmc_queue<T>::concrete_queue<Q>::push(const T&) [with Q = grppi::atomic_mpmc_queue<std::pair<std::experimental::fundamentals_v1::optional<void>, long int> >; T = std::pair<std::experimental::fundamentals_v1::optional<void>, long int>]'
/usr/local/include/grppi/dyn/../seq/../common/mpmc_queue.h:409:10:   required from here
/usr/local/include/grppi/dyn/../seq/../common/mpmc_queue.h:171:26: error: use of deleted function 'std::pair<std::experimental::fundamentals_v1::optional<void>, long int>& std::pair<std::experimental::fundamentals_v1::optional<void>, long int>::operator=(const std::pair<std::experimental::fundamentals_v1::optional<void>, long int>&)'
   buffer_[current%size_] = item;
   ~~~~~~~~~~~~~~~~~~~~~~~^~~~~~
In file included from /usr/local/include/grppi/dyn/../native/worker_pool.h:19,
                 from /usr/local/include/grppi/dyn/../native/parallel_execution_native.h:19,
                 from /usr/local/include/grppi/dyn/dynamic_execution.h:20,
                 from /usr/local/include/grppi/grppi.h:20,
                 from grppi.cpp:6:
/usr/local/include/c++/8.3.0/thread:118:7: error: 'std::thread::thread(_Callable&&, _Args&& ...) [with _Callable = grppi::parallel_execution_native::do_pipeline(Queue&, Transformer&&, OtherTransformers&& ...) const [with Queue = grppi::mpmc_queue<std::pair<std::experimental::fundamentals_v1::optional<std::vector<int>*>, long int> >; Transformer = main(int, char**)::<lambda(std::vector<int>*)>; OtherTransformers = {main(int, char**)::<lambda(std::vector<int, std::allocator<int> >*)>}; typename std::enable_if<is_no_pattern<Consumer>, int>::type <anonymous> = 0]::<lambda()>; _Args = {}; <template-parameter-1-3> = void]', declared using local type 'grppi::parallel_execution_native::do_pipeline(Queue&, Transformer&&, OtherTransformers&& ...) const [with Queue = grppi::mpmc_queue<std::pair<std::experimental::fundamentals_v1::optional<std::vector<int>*>, long int> >; Transformer = main(int, char**)::<lambda(std::vector<int>*)>; OtherTransformers = {main(int, char**)::<lambda(std::vector<int, std::allocator<int> >*)>}; typename std::enable_if<is_no_pattern<Consumer>, int>::type <anonymous> = 0]::<lambda()>', is used but never defined [-fpermissive]
       thread(_Callable&& __f, _Args&&... __args)
       ^~~~~~
In file included from /usr/local/include/grppi/dyn/dynamic_execution.h:20,
                 from /usr/local/include/grppi/grppi.h:20,
                 from grppi.cpp:6:
/usr/local/include/grppi/dyn/../native/parallel_execution_native.h:1004:6: error: 'void grppi::parallel_execution_native::do_pipeline(Queue&, Consumer&&) const [with Queue = grppi::mpmc_queue<std::pair<std::experimental::fundamentals_v1::optional<void>, long int> >; Consumer = main(int, char**)::<lambda(std::vector<int>*)>; typename std::enable_if<is_no_pattern<Consumer>, int>::type <anonymous> = 0]', declared using local type 'main(int, char**)::<lambda(std::vector<int>*)>', is used but never defined [-fpermissive]
 void parallel_execution_native::do_pipeline(
      ^~~~~~~~~~~~~~~~~~~~~~~~~
/usr/local/include/grppi/dyn/../native/parallel_execution_native.h:1004:6: warning: 'void grppi::parallel_execution_native::do_pipeline(Queue&, Consumer&&) const [with Queue = grppi::mpmc_queue<std::pair<std::experimental::fundamentals_v1::optional<void>, long int> >; Consumer = main(int, char**)::<lambda(std::vector<int>*)>; typename std::enable_if<is_no_pattern<Consumer>, int>::type <anonymous> = 0]' used but never defined
